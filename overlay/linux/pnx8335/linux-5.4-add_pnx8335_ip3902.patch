diff -Naur linux-5.4.28.orig/drivers/net/ethernet/ip3902.c linux-5.4.28/drivers/net/ethernet/ip3902.c
--- linux-5.4.28.orig/drivers/net/ethernet/ip3902.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-5.4.28/drivers/net/ethernet/ip3902.c	2020-04-14 14:48:55.227565156 +0300
@@ -0,0 +1,1750 @@
+/* drivers/net/ip3902.c
+ *
+ * Copyright 2008 NXP Semiconductors
+ *	Chris Steel <chris.steel@nxp.com>
+ *
+ * NXP ip3902 embedded 10/100 Ethernet controller support
+ *	Based on ax88796.c, by Ben Dooks.
+	Based on previous ip3902.c by Nikita V. Youshchenko
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/isapnp.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/crc32.h>
+#include <asm/io.h>
+
+#if defined (CONFIG_TIME_DOCTOR)
+#include <linux/timedoctor.h>
+#endif
+
+#define DRVNAME "ip3902-eth"
+#define DRVVERSION "1.00"
+
+/* "Strange hardware" support macros */
+
+/* These control endianness of descriptors and statuses.
+ * If none if LITTLE_ENDIAN_xxx and BIG_ENDIAN_xxx is defined, system endian
+ * is used for xxx */
+#define LITTLE_ENDIAN_DESCRIPTORS
+#undef BIG_ENDIAN_DESCRIPTORS
+#undef LITTLE_ENDIAN_STATUSES
+#define BIG_ENDIAN_STATUSES
+
+#define ETH_RX_SKB_SIZE        0x600   /* 1536 bytes, just over max mtu */
+#define TX_RING_SIZE           128
+#define RX_RING_SIZE           128
+
+#define BYTES_IN_ETHERNET_CRC   4
+
+#define NEXT_TX(i) (((i) == TX_RING_SIZE-1) ? 0 : (i)+1)
+#define NEXT_RX(i) (((i) == RX_RING_SIZE-1) ? 0 : (i)+1)
+
+/* Access to IP3902 registers */
+
+/* Alcatel (Packet Engines) core registers */
+#define MAC1_REG		0x000	/* R/W: MAC configuration register 1 */
+#define MAC2_REG		0x004	/* R/W: MAC configuration register 2 */
+#define IPGT_REG		0x008	/* R/W: Back-to-Back Inter-Packet-Gap register */
+#define IPGR_REG		0x00c	/* R/W: Non Back-to-Back Inter-Packet-Gap register */
+#define CLRT_REG		0x010	/* R/W: Collision window / Retry register */
+#define MAXF_REG		0x014	/* R/W: Maximum Frame register */
+#define SUPP_REG		0x018	/* R/W: PHY Support register */
+#define TEST_REG		0x01C	/* R/W: Test register */
+#define MCFG_REG		0x020	/* R/W: MII Mgmt Con???guration register */
+#define MCMD_REG		0x024	/* R/W: MII Mgmt Command register */
+#define MADR_REG		0x028	/* R/W: MII Mgmt Address register */
+#define MWTD_REG		0x02C	/* WO:  MII Mgmt Write Data register */
+#define MRDD_REG		0x030	/* RO:  MII Mgmt Read Data register */
+#define MIND_REG		0x034	/* RO:  MII Mgmt Indicators register */
+#define SA0_REG			0x040	/* R/W: Station Address 0 register */
+#define SA1_REG			0x044	/* R/W: Station Address 1 register */
+#define SA2_REG			0x048	/* R/W: Station Address 2 register */
+
+/* Control registers */
+#define COMMAND_REG		0x100	/* R/W: Command register */
+#define STATUS_REG		0x104	/* RO:  Status register */
+#define RX_DESC_REG		0x108	/* R/W: Receive descriptor base address register */
+#define RX_STATUS_REG		0x10C	/* R/W: Receive status base address register */
+#define RX_DESC_NUMBER_REG	0x110	/* R/W: Receive number of descriptors register */
+#define RX_PRODUCE_INDEX_REG	0x114	/* RO:  Receive produce index register */
+#define RX_CONSUME_INDEX_REG	0x118	/* R/W: Receive consume index register */
+#define TX_DESC_REG		0x11C	/* R/W: Non real-time transmit descriptor base address register */
+#define TX_STATUS_REG		0x120	/* R/W: Non real-time transmit status base address register */
+#define TX_DESC_NUMBER_REG	0x124	/* R/W: Non real-time transmit number of descriptors register */
+#define TX_PRODUCE_INDEX_REG	0x128	/* R/W: Non real-time transmit produce index register */
+#define TX_CONSUME_INDEX_REG	0x12C	/* RO:  Non real-time transmit consume index register */
+#define TX_RT_DESC_REG		0x130	/* R/W: Real-time transmit descriptor base address register */
+#define TX_RT_STATUS_REG	0x134	/* R/W: Real-time transmit status base address register */
+#define TX_RT_DESC_NUMBER_REG	0x138	/* R/W: Real-time transmit number of descriptors register */
+#define TX_RT_PRODUCE_INDEX_REG	0x13C	/* R/W: Real-time transmit produce index register */
+#define TX_RT_CONSUME_INDEX_REG	0x140	/* RO:  Real-time transmit consume index register */
+#define QOS_TIMEOUT_REG		0x148	/* R/W: Transmit quality of service time-out register */
+#define TSV0_REG		0x158	/* RO:  Transmit status vector 0 register */
+#define TSV1_REG		0x15C	/* RO:  Transmit status vector 1 register */
+#define RSV_REG			0x160	/* RO:  Receive status vector register */
+#define FC_COUNTER_REG		0x170	/* R/W: Flow control counter register */
+#define FC_STATUS_REG		0x174	/* RO:  Flow control status register */
+
+/* Rx filter registers */
+#define FILTER_CTRL_REG		0x200	/* R/W: Receive filter control register */
+#define FILTER_WOL_STATUS_REG	0x204	/* RO:  Receive filter WoL status register */
+#define FILTER_WOL_CLEAR_REG	0x208	/* WO:  Receive filter WoL clear register */
+#define HASH_FILTER_L_REG	0x210	/* R/W: Hash filter table LSBs register */
+#define HASH_FILTER_H_REG	0x214	/* R/W: Hash filter table MSBs register */
+
+/* DVP Standard registers */
+#define INT_STATUS_REG		0xFE0	/* RO:  Interrupt status register */
+#define INT_ENABLE_REG		0xFE4	/* R/W: Interrupt enable register */
+#define INT_CLEAR_REG		0xFE8	/* WO:  Interrupt clear register */
+#define INT_SET_REG		0xFEC	/* WO:  Interrupt set register */
+#define POWERDOWN_REG		0xFF4	/* R/W: Power-down register */
+#define MODULE_ID_REG		0xFFC	/* RO:  Module ID register */
+
+/* Bits for MAC1 register */
+#define MAC1_SOFT_RESET		(1 << 15)
+#define MAC1_TX_FLOW_CONTROL	(1 << 3)
+#define MAC1_RX_FLOW_CONTROL	(1 << 2)
+#define MAC1_RECEIVE_PASS_ALL	(1 << 1)
+#define MAC1_RECEIVE_ENABLE	(1 << 0)
+
+/* Bits for MAC2 register */
+#define MAC2_AUTO_DETECT_PAD_ENABLE	(1 << 7)
+#define MAC2_VLAN_PAD_ENABLE		(1 << 6)
+#define MAC2_PAD_CRC_ENABLE		(1 << 5)
+#define MAC2_CRC_ENABLE			(1 << 4)
+#define MAC2_FULL_DUPLEX		(1 << 0)
+
+#define INITIAL_MAC2	(MAC2_AUTO_DETECT_PAD_ENABLE | MAC2_VLAN_PAD_ENABLE | MAC2_PAD_CRC_ENABLE | MAC2_CRC_ENABLE)
+
+/* Recommended values for IPGT register (see sec. 3.3.2.3 0f datasheet */
+#define IPGT_FD_VALUE	0x15
+#define IPGT_HD_VALUE	0x12
+
+/* Bits for MCMD register */
+#define MCMD_READ		(1 << 0)
+
+/* Bits for MIND register */
+#define MIND_NOT_VALID		(1 << 2)
+#define MIND_BUSY		(1 << 0)
+
+/* Bits for command register */
+#define COMMAND_ENABLE_QOS	(1 << 11)
+#define COMMAND_FULL_DUPLEX	(1 << 10)
+#define COMMAND_RMII_MODE	(1 << 9)
+#define COMMAND_TX_FLOW_CONTROL	(1 << 8)
+#define COMMAND_PROMISC		(1 << 7)
+#define COMMAND_ALLOW_SHORT	(1 << 6)
+#define COMMAND_RX_RESET	(1 << 5)
+#define COMMAND_TX_RESET	(1 << 4)
+#define COMMAND_RESET		(1 << 3)
+#define COMMAND_TX_RT_ENABLE	(1 << 2)
+#define COMMAND_TX_ENABLE	(1 << 1)
+#define COMMAND_RX_ENABLE	(1 << 0)
+
+/* Bits for receive filter control register */
+#define FILTER_ACCEPT_SELF		(1 << 5)
+#define FILTER_ACCEPT_MCAST_HASH	(1 << 4)
+#define FILTER_ACCEPT_UCAST_HASH	(1 << 3)
+#define FILTER_ACCEPT_MCAST_ANY		(1 << 2)
+#define FILTER_ACCEPT_BCAST_ANY		(1 << 1)
+#define FILTER_ACCEPT_UCAST_ANY		(1 << 0)
+
+/* Bits for interrupt registers */
+#define WAKEUP_INT		(1 << 13)
+#define SOFT_INT		(1 << 12)
+#define TX_RT_DONE_INT		(1 << 11)
+#define TX_RT_FINISHED_INT	(1 << 10)
+#define TX_RT_ERROR_INT		(1 << 9)
+#define TX_RT_UNDERRUN_INT	(1 << 8)
+#define TX_DONE_INT		(1 << 7)
+#define TX_FINISHED_INT		(1 << 6)
+#define TX_ERROR_INT		(1 << 5)
+#define TX_UNDERRUN_INT		(1 << 4)
+#define RX_DONE_INT		(1 << 3)
+#define RX_FINISHED_INT		(1 << 2)
+#define RX_ERROR_INT		(1 << 1)
+#define RX_OVERRUN_INT		(1 << 0)
+
+/* Bit for POWERDOWN register */
+#define POWERDOWN_VALUE		(1 << 31)
+
+/* Bits for TX control */
+#define TX_CONTROL_INT		(1 << 31)
+#define TX_CONTROL_LAST		(1 << 30)
+#define TX_CONTROL_CRC		(1 << 29)
+#define TX_CONTROL_PAD		(1 << 28)
+#define TX_CONTROL_HUGE		(1 << 27)
+#define TX_CONTROL_OVERRIDE	(1 << 26)
+
+/* these flags used for non-last fragment of a frame */
+#define TX_CONTROL_ALL_NOTLAST	(TX_CONTROL_CRC | TX_CONTROL_PAD | TX_CONTROL_OVERRIDE)
+/* these flags used for last fragment of a frame, and for single-fragment
+ * frames */
+#define TX_CONTROL_ALL_LAST	(TX_CONTROL_ALL_NOTLAST | TX_CONTROL_LAST)
+
+/* Bits for TX status */
+#define TX_STATUS_ERROR			(1 << 31)
+#define TX_STATUS_UNDERRUN		(1 << 29)
+#define TX_STATUS_LATE_COLLISION	(1 << 28)
+#define TX_STATUS_MANY_COLLISIONS	(1 << 27)
+#define TX_STATUS_MANY_DEFER		(1 << 26)
+#define TX_STATUS_COLLISIONS(s)	((s >> 21) & 15)
+
+/* Bits for RX control */
+#define RX_CONTROL_INT		(1 << 31)
+
+/* Bits for RX status */
+#define RX_STATUS_ERROR			(1 << 31)
+#define RX_STATUS_LAST_FRAG		(1 << 30)
+#define RX_STATUS_OVERRUN		(1 << 28)
+#define RX_STATUS_ALIGNMENT_ERROR	(1 << 27)
+#define RX_STATUS_RANGE_ERROR		(1 << 26)
+#define RX_STATUS_LENGTH_ERROR		(1 << 25)
+#define RX_STATUS_SYMBOL_ERROR		(1 << 24)
+#define RX_STATUS_CRC_ERROR		(1 << 23)
+#define RX_STATUS_BROADCAST		(1 << 22)
+#define RX_STATUS_MULTICAST		(1 << 21)
+#define RX_STATUS_FAIL_FILTER		(1 << 20)
+#define RX_STATUS_VLAN			(1 << 19)
+#define RX_STATUS_CONTROL_FRAME		(1 << 18)
+#define RX_STATUS_LENGTH(s)		((s & 0x7ff) + 1)
+
+/* Bits for RSV register */
+#define RSV_VLAN			(1 << 30)
+#define RSV_CONTROL_FRAME		(1 << 27)
+#define RSV_DRIBBLE_NIBBLE		(1 << 26)
+#define RSV_BROADCAST			(1 << 25)
+#define RSV_MULTICAST			(1 << 24)
+#define RSV_LENGTH_OUT_OF_RANGE		(1 << 22)
+#define RSV_LENGTH_CHECK_ERROR		(1 << 21)
+#define RSV_CRC_ERROR			(1 << 20)
+#define RSV_RECEIVE_CODE_VIOLATION	(1 << 19)
+#define RSV_MASK			0xFFFF
+
+#if defined(CONFIG_IP3902_RX_IRQ) || defined(CONFIG_IP3902_RX_NAPI)
+#define IP3902_RX_DONE_INT RX_DONE_INT
+#define IP3902_RX_CONTROL_INT RX_CONTROL_INT
+#elif defined(CONFIG_IP3902_RX_TIMER)
+#define IP3902_RX_DONE_INT 0
+#define IP3902_RX_CONTROL_INT 0
+#else
+#error unknown method
+#endif
+
+#ifdef IP3902_POWERDOWN_PHY_ON_SUSPEND
+static int keep_phy_control=0;
+#endif
+
+static char *mac_address;
+module_param(mac_address, charp, S_IRUGO);
+MODULE_PARM_DESC(mac_address, "MAC address of the device");
+
+/* device private data */
+struct ip3902_descriptor {
+	unsigned long address;
+	unsigned long control;
+};
+
+struct ip3902_rx_status {
+	unsigned long status;
+	unsigned long hash_crc;
+};
+
+struct ip3902_dma_struct {
+	struct ip3902_descriptor rx_desc[RX_RING_SIZE];
+	struct ip3902_rx_status rx_status[RX_RING_SIZE];
+	struct ip3902_descriptor tx_desc[TX_RING_SIZE];
+	unsigned long tx_status[TX_RING_SIZE];
+};
+
+struct ip3902_private {
+	spinlock_t		mii_lock;
+	struct mii_if_info	mii;
+	u32			msg_enable;
+
+	struct net_device	*ndev;
+	struct platform_device	*pdev;
+	struct resource		*bus;
+	void __iomem		*mem;
+
+	struct ip3902_dma_struct *ds;		/* descriptors and statuses */
+	dma_addr_t ds_dma;
+
+	struct sk_buff *rx_skb[RX_RING_SIZE];	/* where to recieve to */
+	struct sk_buff *tx_skb[TX_RING_SIZE];	/* where to send from */
+	bool tx_first_desc[TX_RING_SIZE];	/* true if this is the first desc of an skb */
+
+	int rx_next_allocate;			/* index in rx ring where skb should be allocated */
+	int rx_next_consume;			/* index in rx ring where data should be read when available */
+	int tx_next_produce;			/* index in tx ring where new data should be put */
+	int tx_next_deallocate;			/* index in tx ring of first not freed skb */
+
+	unsigned char running;
+	unsigned char resume_open;
+#ifdef CONFIG_IP3902_RX_NAPI
+	struct napi_struct napi;
+#elif defined(CONFIG_IP3902_RX_TIMER)
+	struct timer_list rx_timer;		/* RX-queue timer. */
+#endif
+
+	struct timer_list timer;		/* Media check timer. */
+
+	unsigned int int_en_mask; /* Interrupt enable mask */
+	spinlock_t int_lock; /* Interrupt lock */
+};
+
+static void set_duplex_mode(struct net_device *ndev, int duplex);
+
+static inline unsigned long ip3902_read_reg(struct net_device *ndev, int reg)
+{
+	unsigned long value = readl((void * __iomem)(ndev->base_addr + reg));
+	return value;
+}
+
+static inline void ip3902_write_reg(struct net_device *ndev, int reg,
+		unsigned long val)
+{
+	writel(val, (void * __iomem)(ndev->base_addr + reg));
+}
+
+static inline void ip3902_write_tx_desc(struct ip3902_private *ip3902_priv, int pos, unsigned long address, unsigned long control)
+{
+#if defined(BIG_ENDIAN_DESCRIPTORS)
+	ip3902_priv->ds->tx_desc[pos].address = cpu_to_be32(address);
+	ip3902_priv->ds->tx_desc[pos].control = cpu_to_be32(control);
+#elif defined(LITTLE_ENDIAN_DESCRIPTORS)
+	ip3902_priv->ds->tx_desc[pos].address = cpu_to_le32(address);
+	ip3902_priv->ds->tx_desc[pos].control = cpu_to_le32(control);
+#else
+	ip3902_priv->ds->tx_desc[pos].address = address;
+	ip3902_priv->ds->tx_desc[pos].control = control;
+#endif
+	wmb();
+}
+
+static inline void ip3902_read_tx_desc(struct ip3902_private *ip3902_priv, int pos, dma_addr_t *address, int *length)
+{
+#if defined(BIG_ENDIAN_DESCRIPTORS)
+	*address = (dma_addr_t)be32_to_cpu(ip3902_priv->ds->tx_desc[pos].address);
+	*length  = (int)be32_to_cpu(ip3902_priv->ds->tx_desc[pos].control) & 0xffff;
+#elif defined(LITTLE_ENDIAN_DESCRIPTORS)
+	*address = (dma_addr_t)le32_to_cpu(ip3902_priv->ds->tx_desc[pos].address);
+	*length  = (int)le32_to_cpu(ip3902_priv->ds->tx_desc[pos].control) & 0xffff;
+#else
+	*address = (dma_addr_t)ip3902_priv->ds->tx_desc[pos].address;
+	*length  = (int)ip3902_priv->ds->tx_desc[pos].control & 0xffff;
+#endif
+}
+
+static inline unsigned long ip3902_read_tx_status(struct ip3902_private *ip3902_priv, int pos)
+{
+#if defined(BIG_ENDIAN_STATUSES)
+	return be32_to_cpu(ip3902_priv->ds->tx_status[pos]);
+#elif defined(LITTLE_ENDIAN_STATUSES)
+	return le32_to_cpu(ip3902_priv->ds->tx_status[pos]);
+#else
+	return ip3902_priv->ds->tx_status[pos];
+#endif
+}
+
+static inline void ip3902_write_rx_desc(struct ip3902_private *ip3902_priv, int pos, unsigned long address, unsigned long control)
+{
+#if defined(BIG_ENDIAN_DESCRIPTORS)
+	ip3902_priv->ds->rx_desc[pos].address = cpu_to_be32(address);
+	ip3902_priv->ds->rx_desc[pos].control = cpu_to_be32(control);
+#elif defined(LITTLE_ENDIAN_DESCRIPTORS)
+	ip3902_priv->ds->rx_desc[pos].address = cpu_to_le32(address);
+	ip3902_priv->ds->rx_desc[pos].control = cpu_to_le32(control);
+#else
+	ip3902_priv->ds->rx_desc[pos].address = address;
+	ip3902_priv->ds->rx_desc[pos].control = control;
+#endif
+	wmb();
+}
+
+static inline void ip3902_read_rx_desc(struct ip3902_private *ip3902_priv, int pos, dma_addr_t *address, int *length)
+{
+#if defined(BIG_ENDIAN_DESCRIPTORS)
+	*address = (dma_addr_t)be32_to_cpu(ip3902_priv->ds->rx_desc[pos].address);
+	*length  = (int)be32_to_cpu(ip3902_priv->ds->rx_desc[pos].control) & 0xffff;
+#elif defined(LITTLE_ENDIAN_DESCRIPTORS)
+	*address = (dma_addr_t)le32_to_cpu(ip3902_priv->ds->rx_desc[pos].address);
+	*length  = (int)le32_to_cpu(ip3902_priv->ds->rx_desc[pos].control) & 0xffff;
+#else
+	*address = (dma_addr_t)ip3902_priv->ds->rx_desc[pos].address;
+	*length  = (int)ip3902_priv->ds->rx_desc[pos].control & 0xffff;
+#endif
+}
+
+static inline unsigned long ip3902_read_rx_status(struct net_device *ndev, struct ip3902_private *ip3902_priv, int pos)
+{
+#if defined(BIG_ENDIAN_STATUSES)
+	return be32_to_cpu(ip3902_priv->ds->rx_status[pos].status);
+#elif defined(LITTLE_ENDIAN_STATUSES)
+	return le32_to_cpu(ip3902_priv->ds->rx_status[pos].status);
+#else
+	return ip3902_priv->ds->rx_status[pos].status;
+#endif
+}
+
+static inline void ip3902_write_madr_reg(struct net_device *ndev, int phy_id, int location)
+{
+	/* assume ranges of phy_id and location are correct - we set masks in
+	 * struct mii_if_info for that */
+	
+	unsigned long val = (phy_id << 8) | location;
+	ip3902_write_reg(ndev, MADR_REG, val);
+}
+
+static inline int ip3902_wait_mdio_op_complete(struct net_device *ndev, unsigned long mask)
+{
+	int timeout = 10000;		/* to avoid hangup in case of unexpected badness ... */
+
+	while (--timeout > 0)
+	{
+		if ((ip3902_read_reg(ndev, MIND_REG) & mask) == 0)
+		{
+			return 0;
+		}
+		udelay(1);
+	}
+
+	return -EIO;
+}
+
+static int ip3902_mdio_read(struct net_device *ndev, int phy_id, int location)
+{
+	ip3902_write_madr_reg(ndev, phy_id, location);
+	ip3902_write_reg(ndev, MCMD_REG, 0);
+	ip3902_write_reg(ndev, MCMD_REG, MCMD_READ);
+	if (ip3902_wait_mdio_op_complete(ndev, MIND_NOT_VALID | MIND_BUSY) < 0)
+	{
+		return 0;
+	}
+	else
+	{
+		unsigned long value = ip3902_read_reg(ndev, MRDD_REG) & 0xffff;
+		return value;
+	}
+}
+
+static void ip3902_mdio_write(struct net_device *ndev, int phy_id, int location, int value)
+{
+	ip3902_write_madr_reg(ndev, phy_id, location);
+	ip3902_write_reg(ndev, MWTD_REG, value & 0xffff);
+	ip3902_wait_mdio_op_complete(ndev, MIND_BUSY);
+}
+
+static int ip3902_phy_reset(struct net_device *ndev, struct ip3902_private *ip3902_priv)
+{
+	int err;
+
+	err = ip3902_mdio_read(ndev, ip3902_priv->mii.phy_id, MII_BMCR);
+	if (err < 0)
+		return err;
+	err |= BMCR_RESET;
+	ip3902_mdio_write(ndev, ip3902_priv->mii.phy_id, MII_BMCR, err);
+	msleep(500);
+
+	return 0;
+}
+
+static inline int ip3902_nr_free_descs(int head, int tail, int size)
+{
+	int free;
+
+	if (head >= tail)
+	{
+		free = (tail + size) - head;
+	}
+	else
+	{
+		free = tail - head;
+	}
+
+	if(free) // for avoid overflow
+		--free;
+
+	return free;
+}
+
+static void ip3902_eth_rx_refill_descs(struct net_device *ndev, struct ip3902_private *ip3902_priv)
+{
+	do
+	{
+		int rx_index = ip3902_priv->rx_next_allocate;
+		struct sk_buff *skb = netdev_alloc_skb(ndev, ETH_RX_SKB_SIZE + dma_get_cache_alignment());
+
+		if (skb)
+		{
+			int unaligned = (((u32)skb->data) + ETH_HLEN) & (dma_get_cache_alignment() - 1);
+			unsigned long desc_address;
+
+			if (unaligned)
+			{
+				skb_reserve(skb, (dma_get_cache_alignment() - unaligned));
+			}
+			desc_address = dma_map_single(&ip3902_priv->pdev->dev, skb->data, ETH_RX_SKB_SIZE, DMA_FROM_DEVICE);
+			ip3902_write_rx_desc(ip3902_priv, rx_index, desc_address, (ETH_RX_SKB_SIZE -1) | IP3902_RX_CONTROL_INT);
+
+			ip3902_priv->rx_skb[rx_index] = skb;
+			ip3902_priv->rx_next_allocate = NEXT_RX(rx_index);
+		}
+		else
+		{
+			ip3902_write_reg(ndev, RX_CONSUME_INDEX_REG, ip3902_priv->rx_next_allocate);
+			return;
+		}
+	} while (ip3902_priv->rx_next_allocate != ip3902_priv->rx_next_consume);
+
+	ip3902_write_reg(ndev, RX_CONSUME_INDEX_REG, ip3902_priv->rx_next_allocate);
+}
+
+static int ip3902_eth_receive_queue(struct net_device *ndev, struct ip3902_private *ip3902_priv, int budget)
+{
+	int rx_index    = ip3902_priv->rx_next_consume;
+	int write_index = ip3902_read_reg(ndev, RX_PRODUCE_INDEX_REG);
+	int received = 0;
+	int limit;
+
+	/* Hardware didn't receive anything */
+	if (rx_index == write_index)
+		return 0;
+
+#if defined (CONFIG_TIME_DOCTOR)
+	timeDoctor_Info(TDI_COMMAND(TDI_START, TDI_EVENT), CHAR_ARRAY_TO_U32("RX  "), CHAR_ARRAY_TO_U32("3902"));
+#endif
+
+	do
+	{
+		limit = write_index;
+
+		while (rx_index != limit)
+		{
+			unsigned long status = ip3902_read_rx_status(ndev, ip3902_priv, rx_index);
+
+			if (!(status & RX_STATUS_LAST_FRAG))
+			{
+				printk(DRVNAME ": broken RX status: %08lx\n", status);
+				continue;
+			}
+
+			if (status & RX_STATUS_FAIL_FILTER)
+			{
+				continue;
+			}
+
+			/* Looks like hardware returns RANGE_ERROR for each frame */
+			if (status & (RX_STATUS_OVERRUN | RX_STATUS_ALIGNMENT_ERROR | RX_STATUS_LENGTH_ERROR | RX_STATUS_CRC_ERROR))
+			{
+				ndev->stats.rx_errors++;
+
+				if (status & RX_STATUS_OVERRUN)
+				{
+					ndev->stats.rx_fifo_errors++;
+				}
+				if (status & RX_STATUS_ALIGNMENT_ERROR)
+				{
+					ndev->stats.rx_frame_errors++;
+				}
+				if (status & (RX_STATUS_RANGE_ERROR | RX_STATUS_LENGTH_ERROR))
+				{
+					ndev->stats.rx_length_errors++;
+				}
+				if (status & RX_STATUS_CRC_ERROR)
+				{
+					ndev->stats.rx_crc_errors++;
+				}
+			}
+			else
+			{
+				if (--budget < 0)
+				{
+					/* we got packets, but no quota */
+					/* store current ring pointer state */
+					ip3902_priv->rx_next_consume = rx_index;
+#if defined (CONFIG_TIME_DOCTOR)
+					timeDoctor_Info(TDI_COMMAND(TDI_STOP, TDI_EVENT), CHAR_ARRAY_TO_U32("RX  "), CHAR_ARRAY_TO_U32("3902"));
+#endif
+					return received;
+				}
+				else
+				{
+					struct sk_buff *skb    = ip3902_priv->rx_skb[rx_index];
+					int             length = RX_STATUS_LENGTH(status);
+					dma_addr_t      data_addr;
+					int             data_length;
+
+					ndev->stats.rx_packets++;
+					ndev->stats.rx_bytes += length;
+					if (status & RX_STATUS_MULTICAST)
+					{
+						ndev->stats.multicast++;
+					}
+					skb_put(skb, length - BYTES_IN_ETHERNET_CRC);
+					skb->protocol = eth_type_trans(skb, ndev);
+#if defined (CONFIG_TIME_DOCTOR)
+					timeDoctor_Info(TDI_COMMAND(TDI_START, TDI_EVENT), CHAR_ARRAY_TO_U32("RSKB"), CHAR_ARRAY_TO_U32("3902"));
+#endif
+#ifdef CONFIG_IP3902_RX_NAPI
+					netif_receive_skb(skb);
+#else
+					netif_rx(skb);
+#endif
+#if defined (CONFIG_TIME_DOCTOR)
+					timeDoctor_Info(TDI_COMMAND(TDI_STOP, TDI_EVENT), CHAR_ARRAY_TO_U32("RSKB"), CHAR_ARRAY_TO_U32("3902"));
+#endif
+					ip3902_read_rx_desc(ip3902_priv, rx_index, &data_addr, &data_length);
+					dma_unmap_single(&ip3902_priv->pdev->dev, data_addr, ETH_RX_SKB_SIZE, DMA_FROM_DEVICE);
+
+					ip3902_priv->rx_skb[rx_index] = NULL;
+					received++;
+				}
+			}
+			rx_index = NEXT_RX(rx_index);
+		}
+
+#if defined(CONFIG_IP3902_RX_IRQ) || defined(CONFIG_IP3902_RX_NAPI)
+		ip3902_write_reg(ndev, INT_CLEAR_REG, RX_DONE_INT);
+		ip3902_write_reg(ndev, INT_CLEAR_REG, 0);
+#endif
+
+		ip3902_priv->rx_next_consume = rx_index;
+		ip3902_eth_rx_refill_descs(ndev, ip3902_priv);
+		write_index = ip3902_read_reg(ndev, RX_PRODUCE_INDEX_REG);
+	} while (limit != write_index);
+
+#if defined (CONFIG_TIME_DOCTOR)
+	timeDoctor_Info(TDI_COMMAND(TDI_STOP, TDI_EVENT), CHAR_ARRAY_TO_U32("RX  "), CHAR_ARRAY_TO_U32("3902"));
+#endif
+
+	return received;
+}
+
+#define ip3902_eth_free_completed_tx_descs(ndev, priv) ip3902_eth_free_tx_descs(ndev, priv, 0)
+#define ip3902_eth_free_all_tx_descs(ndev, priv) ip3902_eth_free_tx_descs(ndev, priv, 1)
+
+static void ip3902_eth_free_tx_descs(struct net_device *ndev, struct ip3902_private *ip3902_priv, int force)
+{
+	int limit;
+
+	if (force)
+	{
+		limit = ip3902_priv->tx_next_produce;
+	}
+	else
+	{
+		limit = ip3902_read_reg(ndev, TX_CONSUME_INDEX_REG);
+	}
+
+	while (ip3902_priv->tx_next_deallocate != limit)
+	{
+		int             length;
+		int             tx_index;
+		unsigned long   status;
+		dma_addr_t      addr;
+		struct sk_buff *skb;
+
+		tx_index = ip3902_priv->tx_next_deallocate;
+
+		ip3902_priv->tx_next_deallocate = NEXT_TX(tx_index);
+		ip3902_read_tx_desc(ip3902_priv, tx_index, &addr, &length);
+		skb = ip3902_priv->tx_skb[tx_index];
+
+		status = ip3902_read_tx_status(ip3902_priv, tx_index);
+		if (status & TX_STATUS_ERROR)
+		{
+			ndev->stats.tx_errors++;
+			if (status & TX_STATUS_LATE_COLLISION)
+			{
+				ndev->stats.tx_aborted_errors++;
+			}
+			if (status & (TX_STATUS_MANY_COLLISIONS | TX_STATUS_MANY_DEFER))
+			{
+				ndev->stats.tx_window_errors++;
+			}
+		}
+		else
+		{
+			ndev->stats.tx_packets++;
+			ndev->stats.tx_bytes   += length;
+			ndev->stats.collisions += TX_STATUS_COLLISIONS(status);
+		}
+
+		if (skb)
+		{
+			ip3902_priv->tx_skb[tx_index] = NULL;
+		}
+
+		if (ip3902_priv->tx_first_desc[tx_index] == true)
+		{
+			dma_unmap_single(&ip3902_priv->pdev->dev, addr, length, DMA_TO_DEVICE);
+		}
+		else
+		{
+			dma_unmap_page(&ip3902_priv->pdev->dev, addr, length, DMA_TO_DEVICE);
+		}
+
+		if (skb)
+		{
+			dev_kfree_skb_irq(skb);
+		}
+	}
+}
+
+static void ip3902_reset_tx(struct net_device *ndev, struct ip3902_private *ip3902_priv, int initial)
+{
+	unsigned long val;
+
+	/* Reset Tx hardware */
+	val = ip3902_read_reg(ndev, COMMAND_REG);
+	val &= ~(COMMAND_TX_RT_ENABLE | COMMAND_TX_ENABLE);
+	val |= COMMAND_TX_RESET;
+	ip3902_write_reg(ndev, COMMAND_REG, val);
+
+	if (!initial)
+	{
+		ip3902_eth_free_all_tx_descs(ndev, ip3902_priv);
+	}
+
+	ip3902_priv->tx_next_produce    = 0;
+	ip3902_priv->tx_next_deallocate = 0;
+
+	/* Configure Tx registers */
+	ip3902_write_reg(ndev, TX_DESC_REG,   ip3902_priv->ds_dma + offsetof(struct ip3902_dma_struct, tx_desc));
+	ip3902_write_reg(ndev, TX_STATUS_REG, ip3902_priv->ds_dma + offsetof(struct ip3902_dma_struct, tx_status));
+	ip3902_write_reg(ndev, TX_DESC_NUMBER_REG, TX_RING_SIZE - 1);
+	ip3902_write_reg(ndev, TX_PRODUCE_INDEX_REG, ip3902_priv->tx_next_produce);
+	ip3902_write_reg(ndev, TX_CONSUME_INDEX_REG, ip3902_priv->tx_next_deallocate);
+}
+
+static void ip3902_reset_rx(struct net_device *ndev, struct ip3902_private *ip3902_priv, int init)
+{
+	unsigned long val;
+
+	/* Reset Rx hardware */
+	val = ip3902_read_reg(ndev, COMMAND_REG);
+	val &= ~COMMAND_RX_ENABLE;
+	val |= COMMAND_RX_RESET;
+	ip3902_write_reg(ndev, COMMAND_REG, val);
+
+	/* Set maximum frame size register */
+	ip3902_write_reg(ndev, MAXF_REG, ETH_RX_SKB_SIZE);
+
+	if (init)
+	{
+		ip3902_priv->rx_next_allocate   = 0;
+		ip3902_priv->rx_next_consume    = 0;
+		ip3902_eth_rx_refill_descs(ndev, ip3902_priv);
+	}
+
+	/* Prepare skb's for Rx (any skb's already prepared will be reused)
+	 * and configure Rx registers */
+	ip3902_write_reg(ndev, RX_DESC_REG, ip3902_priv->ds_dma + offsetof(struct ip3902_dma_struct, rx_desc));
+	ip3902_write_reg(ndev, RX_STATUS_REG, ip3902_priv->ds_dma + offsetof(struct ip3902_dma_struct, rx_status));
+	ip3902_write_reg(ndev, RX_DESC_NUMBER_REG, RX_RING_SIZE - 1);
+	ip3902_write_reg(ndev, RX_PRODUCE_INDEX_REG, ip3902_priv->rx_next_consume);
+}
+
+static inline void ip3902_start_tx(struct net_device *ndev)
+{
+	unsigned long val;
+	
+	val = ip3902_read_reg(ndev, COMMAND_REG);
+	val |= COMMAND_TX_ENABLE;
+	ip3902_write_reg(ndev, COMMAND_REG, val);
+}
+
+static inline void ip3902_start_rx(struct net_device *ndev)
+{
+	unsigned long val;
+	
+	/* First on high-level ... */
+	val = ip3902_read_reg(ndev, COMMAND_REG);
+	val |= (COMMAND_RX_ENABLE | COMMAND_ALLOW_SHORT);
+	ip3902_write_reg(ndev, COMMAND_REG, val);
+
+	/* ... and then on low-level (after high level is ready to receive) */
+	val = ip3902_read_reg(ndev, MAC1_REG);
+	val |= MAC1_RECEIVE_ENABLE;	/* flow control frames won't be passed to driver */
+	ip3902_write_reg(ndev, MAC1_REG, val);
+}
+
+#ifdef CONFIG_IP3902_RX_TIMER
+/*
+ * RX-queue timer
+ */
+static void ip3902_rx_timer(struct timer_list *t)
+{
+	struct ip3902_private *ip3902_priv = from_timer(ip3902_priv, t, rx_timer);
+
+	ip3902_eth_receive_queue(ip3902_priv->ndev, ip3902_priv, RX_RING_SIZE);
+
+	/* We lock RX-queue in every tick. */
+	ip3902_priv->rx_timer.expires = jiffies + 1;
+	add_timer(&ip3902_priv->rx_timer);
+}
+#endif
+
+/*
+ * Media and Link monitoring timer
+ */
+static void ip3902_timer(struct timer_list *t)
+{
+	struct ip3902_private *ip3902_priv = from_timer(ip3902_priv, t, timer);
+
+	if(mii_check_media(&ip3902_priv->mii, netif_msg_link(ip3902_priv), 0))
+		set_duplex_mode(ip3902_priv->ndev, ip3902_priv->mii.full_duplex);
+
+	/* We must continue to monitor the media. */
+	ip3902_priv->timer.expires = jiffies + (2 * HZ);
+	add_timer(&ip3902_priv->timer);
+}
+
+/* Interrupt handler body - split out to use in interrupt handler.
+ *
+ * Internal routine, called with lock held. */
+static void ip3902_do_handle_interrupt(struct net_device *ndev,	struct ip3902_private *ip3902_priv, unsigned long status)
+{
+	unsigned long flags;
+
+#if defined(CONFIG_IP3902_RX_IRQ) || defined(CONFIG_IP3902_RX_NAPI)
+	if (status & RX_DONE_INT)
+	{
+#if defined(CONFIG_IP3902_RX_IRQ)
+		ip3902_eth_receive_queue(ndev, ip3902_priv, RX_RING_SIZE);
+#else
+#if defined (CONFIG_TIME_DOCTOR)
+		timeDoctor_Info(TDI_COMMAND(TDI_START, TDI_EVENT), CHAR_ARRAY_TO_U32("DISI"), CHAR_ARRAY_TO_U32("3902"));
+#endif
+		spin_lock_irqsave(&ip3902_priv->int_lock, flags);
+		ip3902_priv->int_en_mask &= ~RX_DONE_INT;
+		ip3902_write_reg(ndev, INT_ENABLE_REG, ip3902_priv->int_en_mask);
+		spin_unlock_irqrestore(&ip3902_priv->int_lock, flags);
+		napi_schedule(&ip3902_priv->napi);
+#if defined (CONFIG_TIME_DOCTOR)
+		timeDoctor_Info(TDI_COMMAND(TDI_STOP, TDI_EVENT), CHAR_ARRAY_TO_U32("DISI"), CHAR_ARRAY_TO_U32("3902"));
+#endif
+#endif
+	}
+#endif
+
+	if (status & TX_FINISHED_INT)
+	{
+		ip3902_write_reg(ndev, INT_CLEAR_REG, TX_FINISHED_INT);
+		ip3902_write_reg(ndev, INT_CLEAR_REG, 0);
+		spin_lock_irqsave(&ip3902_priv->int_lock, flags);
+		ip3902_priv->int_en_mask &= ~TX_FINISHED_INT;
+		ip3902_write_reg(ndev, INT_ENABLE_REG, ip3902_priv->int_en_mask);
+		spin_unlock_irqrestore(&ip3902_priv->int_lock, flags);
+		if(netif_queue_stopped(ndev))
+			netif_wake_queue(ndev);
+	}
+
+	if (status & TX_UNDERRUN_INT)
+	{
+#if defined (CONFIG_TIME_DOCTOR)
+		timeDoctor_Info(TDI_COMMAND(TDI_START, TDI_EVENT), CHAR_ARRAY_TO_U32("TX_U"), CHAR_ARRAY_TO_U32("3902"));
+#endif
+		ip3902_write_reg(ndev, INT_CLEAR_REG, TX_UNDERRUN_INT);
+		ip3902_write_reg(ndev, INT_CLEAR_REG, 0);
+		printk(KERN_ERR DRVNAME ": %s: fatal Tx underrun, resetting Tx\n", ndev->name);
+		ip3902_reset_tx(ndev, ip3902_priv, 0);
+		ip3902_start_tx(ndev);
+#if defined (CONFIG_TIME_DOCTOR)
+		timeDoctor_Info(TDI_COMMAND(TDI_STOP, TDI_EVENT), CHAR_ARRAY_TO_U32("TX_U"), CHAR_ARRAY_TO_U32("3902"));
+#endif
+	}
+
+	if (status & RX_OVERRUN_INT)
+	{
+#if defined (CONFIG_TIME_DOCTOR)
+		timeDoctor_Info(TDI_COMMAND(TDI_START, TDI_EVENT), CHAR_ARRAY_TO_U32("RX_O"), CHAR_ARRAY_TO_U32("3902"));
+#endif
+		ip3902_write_reg(ndev, INT_CLEAR_REG, RX_OVERRUN_INT);
+		ip3902_write_reg(ndev, INT_CLEAR_REG, 0);
+		printk(KERN_ERR DRVNAME ": %s: fatal Rx overrun, resetting Rx\n", ndev->name);
+		ip3902_reset_rx(ndev, ip3902_priv, 0);
+		ip3902_start_rx(ndev);
+#if defined (CONFIG_TIME_DOCTOR)
+		timeDoctor_Info(TDI_COMMAND(TDI_STOP, TDI_EVENT), CHAR_ARRAY_TO_U32("RX_O"), CHAR_ARRAY_TO_U32("3902"));
+#endif
+	}
+}
+
+static irqreturn_t ip3902_interrupt(int irq, void *dev_instance)
+{
+	struct net_device *ndev = (struct net_device *) dev_instance;
+	struct ip3902_private *ip3902_priv = netdev_priv(ndev);
+	unsigned long status;
+
+	status = ip3902_read_reg(ndev, INT_STATUS_REG) & ip3902_priv->int_en_mask;
+	do
+	{
+		if (!status)
+		{
+#if defined (CONFIG_TIME_DOCTOR)
+			timeDoctor_Info(TDI_COMMAND(TDI_START, TDI_EVENT), CHAR_ARRAY_TO_U32("INT"), CHAR_ARRAY_TO_U32("3902"));
+			timeDoctor_Info(TDI_COMMAND(TDI_STOP, TDI_EVENT), CHAR_ARRAY_TO_U32("INT"), CHAR_ARRAY_TO_U32("3902"));
+#endif
+			return IRQ_NONE;
+		}
+		else
+		{
+			ip3902_do_handle_interrupt(ndev, ip3902_priv, status);
+			status = ip3902_read_reg(ndev, INT_STATUS_REG) & ip3902_priv->int_en_mask;
+		}
+	} while (status);
+
+	return IRQ_HANDLED;
+}
+
+static int eth_alloc_tx_desc_index(struct ip3902_private *ip3902_priv)
+{
+	int tx_desc_curr;
+
+	tx_desc_curr = ip3902_priv->tx_next_produce;
+	ip3902_priv->tx_next_produce = NEXT_TX(tx_desc_curr);
+
+	return tx_desc_curr;
+}
+
+static void eth_tx_fill_frag_descs(struct ip3902_private *ip3902_priv, struct sk_buff *skb)
+{
+	int frag = 0;
+	int tx_index;
+
+	do
+	{
+		skb_frag_t   *this_frag = &skb_shinfo(skb)->frags[frag];
+		unsigned long desc_address;
+		unsigned long desc_control;
+
+		tx_index = eth_alloc_tx_desc_index(ip3902_priv);
+
+		if (frag == (skb_shinfo(skb)->nr_frags - 1))
+		{
+			desc_control = (skb_frag_size(this_frag) - 1) | TX_CONTROL_ALL_LAST;
+			ip3902_priv->tx_skb[tx_index] = skb;
+		}
+		else
+		{
+			desc_control = (skb_frag_size(this_frag) - 1) | TX_CONTROL_ALL_NOTLAST;
+			ip3902_priv->tx_skb[tx_index] = NULL;
+		}
+
+		ip3902_priv->tx_first_desc[tx_index] = false;
+		desc_address = skb_frag_dma_map(&ip3902_priv->pdev->dev, this_frag,
+						skb_frag_off(this_frag),
+						skb_frag_size(this_frag),
+						DMA_TO_DEVICE);
+		ip3902_write_tx_desc(ip3902_priv, tx_index, desc_address, desc_control);
+	} while (++frag < skb_shinfo(skb)->nr_frags);
+}
+
+static int ip3902_submit_skb_for_tx (struct net_device *ndev, struct sk_buff *skb)
+{
+	struct ip3902_private *ip3902_priv = netdev_priv(ndev);
+	int nr_frags;
+	int free_desc;
+	int ret = 0;
+
+	free_desc = ip3902_nr_free_descs(ip3902_priv->tx_next_produce, ip3902_priv->tx_next_deallocate, TX_RING_SIZE);
+	nr_frags  = skb_shinfo(skb)->nr_frags;
+
+	if (free_desc <= nr_frags)
+	{
+		ip3902_eth_free_completed_tx_descs(ndev, ip3902_priv);
+		free_desc = ip3902_nr_free_descs(ip3902_priv->tx_next_produce, ip3902_priv->tx_next_deallocate, TX_RING_SIZE);
+	}
+	
+	if (free_desc > nr_frags)
+	{
+		unsigned long desc_address;
+		unsigned long desc_control;
+		int tx_index;
+		int length;
+
+		tx_index = eth_alloc_tx_desc_index(ip3902_priv);
+
+		if (nr_frags)
+		{
+			eth_tx_fill_frag_descs(ip3902_priv, skb);
+			length = skb_headlen(skb);
+			desc_control = (length - 1) | TX_CONTROL_ALL_NOTLAST;
+			ip3902_priv->tx_skb[tx_index] = NULL;
+		}
+		else
+		{
+			length = skb->len;
+			desc_control = (length - 1) | TX_CONTROL_ALL_LAST;
+			ip3902_priv->tx_skb[tx_index] = skb;
+		}
+
+		ip3902_priv->tx_first_desc[tx_index] = true;
+		desc_address  = dma_map_single(&ip3902_priv->pdev->dev, skb->data, length, DMA_TO_DEVICE);
+
+		ip3902_write_tx_desc(ip3902_priv, tx_index, desc_address, desc_control);
+		ip3902_write_reg(ndev, TX_PRODUCE_INDEX_REG, ip3902_priv->tx_next_produce);
+		ip3902_eth_free_completed_tx_descs(ndev, ip3902_priv);
+	}
+	else
+	{
+		ret = -ENOMEM;
+	}
+
+	return ret;
+}
+
+static int ip3902_start_xmit (struct sk_buff *skb, struct net_device *ndev)
+{
+	struct ip3902_private *ip3902_priv = (struct ip3902_private*)netdev_priv(ndev);
+	unsigned long flags;
+	int ret;
+
+	BUG_ON(netif_queue_stopped(ndev));
+	BUG_ON(skb == NULL);
+#if defined (CONFIG_TIME_DOCTOR)
+	timeDoctor_Info(TDI_COMMAND(TDI_START, TDI_EVENT), CHAR_ARRAY_TO_U32("TX  "), CHAR_ARRAY_TO_U32("3902"));
+#endif
+
+	ret = ip3902_submit_skb_for_tx (ndev, skb);
+	if (ret) {
+		netif_stop_queue(ndev);
+		spin_lock_irqsave(&ip3902_priv->int_lock, flags);
+		ip3902_priv->int_en_mask |= TX_FINISHED_INT;
+		ip3902_write_reg(ndev, INT_ENABLE_REG, ip3902_priv->int_en_mask);
+		spin_unlock_irqrestore(&ip3902_priv->int_lock, flags);
+		ret = NETDEV_TX_BUSY;
+	} else {
+		ndev->stats.tx_bytes += skb->len;
+		ndev->stats.tx_packets++;
+	}
+#if defined (CONFIG_TIME_DOCTOR)
+	timeDoctor_Info(TDI_COMMAND(TDI_STOP, TDI_EVENT), CHAR_ARRAY_TO_U32("TX  "), CHAR_ARRAY_TO_U32("3902"));
+#endif
+
+	return ret;		/* success */
+}
+
+static void ip3902_do_set_rx_filter(struct net_device *ndev, struct ip3902_private *ip3902_priv)
+{
+	unsigned long creg, freg;
+
+	creg = ip3902_read_reg(ndev, COMMAND_REG);
+	if (ndev->flags & IFF_PROMISC)
+	{
+		/* If interface is in promiscuous mode, just disable filter */
+		ip3902_write_reg(ndev, COMMAND_REG, creg | COMMAND_PROMISC);
+		return;
+	}
+	/* Enable filter */
+	ip3902_write_reg(ndev, COMMAND_REG, creg & ~COMMAND_PROMISC);
+
+	/* Frames for self address and broadcast frames are always accepted */
+	freg = FILTER_ACCEPT_SELF | FILTER_ACCEPT_BCAST_ANY;
+
+	if (ndev->flags & IFF_ALLMULTI)
+	{
+		/* Accept all multicast frames */
+		freg |= FILTER_ACCEPT_MCAST_ANY;
+	}
+	else if (ndev->mc.count > 0)
+	{
+		/* Accept some multicast frames */
+		u64 hash_mask = 0;
+		struct netdev_hw_addr *ha;
+
+		freg |= FILTER_ACCEPT_MCAST_HASH;
+
+		netdev_for_each_mc_addr(ha, ndev)
+		{
+			int b = (ether_crc(ETH_ALEN, ha->addr) >> 23) & 0x3f;
+			hash_mask |= (1 << b);
+		}
+
+		ip3902_write_reg(ndev, HASH_FILTER_L_REG, hash_mask & 0xffffffff);
+		ip3902_write_reg(ndev, HASH_FILTER_H_REG, hash_mask >> 32);
+	}
+
+	ip3902_write_reg(ndev, FILTER_CTRL_REG, freg);
+}
+
+static void ip3902_set_rx_filter(struct net_device *ndev)
+{
+	struct ip3902_private *ip3902_priv = (struct ip3902_private*)netdev_priv(ndev);
+	ip3902_do_set_rx_filter(ndev, ip3902_priv);
+}
+
+static void set_duplex_mode(struct net_device *ndev, int duplex)
+{
+	unsigned long val;
+
+	if (duplex)
+	{
+		/* Full Duplex mode */
+		
+		val = ip3902_read_reg(ndev, MAC2_REG);
+		val |= MAC2_FULL_DUPLEX;
+		ip3902_write_reg(ndev, MAC2_REG, val);
+
+		ip3902_write_reg(ndev, IPGT_REG, IPGT_FD_VALUE);
+
+		val = ip3902_read_reg(ndev, COMMAND_REG);
+		val |= COMMAND_FULL_DUPLEX;
+		ip3902_write_reg(ndev, COMMAND_REG, val);
+	}
+	else
+	{
+		/* Half Duplex mode */
+
+		val = ip3902_read_reg(ndev, MAC2_REG);
+		val &= ~MAC2_FULL_DUPLEX;
+		ip3902_write_reg(ndev, MAC2_REG, val);
+
+		ip3902_write_reg(ndev, IPGT_REG, IPGT_HD_VALUE);
+
+		val = ip3902_read_reg(ndev, COMMAND_REG);
+		val &= ~COMMAND_FULL_DUPLEX;
+		ip3902_write_reg(ndev, COMMAND_REG, val);
+	}
+}
+
+static int ip3902_ioctl(struct net_device *ndev, struct ifreq *req, int cmd)
+{
+	struct ip3902_private *ip3902_priv = netdev_priv(ndev);
+	unsigned int duplex_changed = 0;
+	int rc;
+
+	if (netif_running(ndev))
+	{
+		unsigned long flags;
+		spin_lock_irqsave(&ip3902_priv->mii_lock, flags);
+		rc = generic_mii_ioctl(&ip3902_priv->mii, if_mii(req), cmd, &duplex_changed);
+		spin_unlock_irqrestore(&ip3902_priv->mii_lock, flags);
+	}
+	else
+	{
+		return -EINVAL;
+	}
+
+	if (duplex_changed)
+	{
+		set_duplex_mode(ndev, ip3902_priv->mii.full_duplex);
+	}
+	return rc;
+}
+
+/* ethtool ops */
+
+static void ip3902_get_drvinfo(struct net_device *ndev,
+			   struct ethtool_drvinfo *info)
+{
+	struct ip3902_private *ip3902_priv = netdev_priv(ndev);
+
+	strcpy(info->driver, DRVNAME);
+	strcpy(info->version, DRVVERSION);
+	strcpy(info->bus_info, ip3902_priv->ndev->name);
+}
+
+static int ip3902_get_settings(struct net_device *ndev, struct ethtool_link_ksettings *cmd)
+{
+	struct ip3902_private *ip3902_priv = netdev_priv(ndev);
+	unsigned long flags;
+
+	spin_lock_irqsave(&ip3902_priv->mii_lock, flags);
+	mii_ethtool_get_link_ksettings(&ip3902_priv->mii, cmd);
+	spin_unlock_irqrestore(&ip3902_priv->mii_lock, flags);
+
+	return 0;
+}
+
+static int ip3902_set_settings(struct net_device *ndev, const struct ethtool_link_ksettings *cmd)
+{
+	struct ip3902_private *ip3902_priv = netdev_priv(ndev);
+	unsigned long flags;
+	int rc;
+
+	spin_lock_irqsave(&ip3902_priv->mii_lock, flags);
+	rc = mii_ethtool_set_link_ksettings(&ip3902_priv->mii, cmd);
+	spin_unlock_irqrestore(&ip3902_priv->mii_lock, flags);
+
+	return rc;
+}
+
+static int ip3902_nway_reset(struct net_device *ndev)
+{
+	struct ip3902_private *ip3902_priv = netdev_priv(ndev);
+	return mii_nway_restart(&ip3902_priv->mii);
+}
+
+static u32 ip3902_get_link(struct net_device *ndev)
+{
+	struct ip3902_private *ip3902_priv = netdev_priv(ndev);
+	return mii_link_ok(&ip3902_priv->mii);
+}
+
+static const struct ethtool_ops ip3902_ethtool_ops = {
+	.get_drvinfo	= ip3902_get_drvinfo,
+	.get_link_ksettings	= ip3902_get_settings,
+	.set_link_ksettings	= ip3902_set_settings,
+	.nway_reset	= ip3902_nway_reset,
+	.get_link 	= ip3902_get_link,
+};
+
+/* setup code */
+
+static void ip3902_eth_update_mac_address(struct net_device *ndev)
+{
+	ip3902_write_reg(ndev, SA0_REG,	(ndev->dev_addr[5] << 8) | ndev->dev_addr[4]);
+	ip3902_write_reg(ndev, SA1_REG,	(ndev->dev_addr[3] << 8) | ndev->dev_addr[2]);
+	ip3902_write_reg(ndev, SA2_REG,	(ndev->dev_addr[1] << 8) | ndev->dev_addr[0]);
+}
+
+static int ip3902_eth_set_mac_address(struct net_device *ndev, void *addr)
+{
+	int i;
+
+	for (i = 0; i < 6; i++)
+	{
+		/* +2 is for the offset of the HW addr type */
+		ndev->dev_addr[i] = ((unsigned char *)addr)[i + 2];
+	}
+	ip3902_eth_update_mac_address(ndev);
+	return 0;
+}
+
+static void ip3902_hw_deinit(struct net_device *ndev)
+{
+#ifdef CONFIG_IP3902_RX_TIMER
+	struct ip3902_private *ip3902_priv = netdev_priv(ndev);
+#endif
+	unsigned long val;
+
+#ifdef CONFIG_IP3902_RX_TIMER
+	del_timer(&ip3902_priv->rx_timer);
+#endif
+
+	/* Stop Rx and Tx hardware and disable interrupts */
+	val = ip3902_read_reg(ndev, COMMAND_REG);
+	val &= ~(COMMAND_TX_ENABLE | COMMAND_RX_ENABLE);
+	ip3902_write_reg(ndev, COMMAND_REG, val);
+	ip3902_write_reg(ndev, INT_ENABLE_REG, 0);
+
+#ifndef IP3902_POWERDOWN_PHY_ON_SUSPEND
+	/* Put low-level hardware into reset, and high-level into poweroff */
+	ip3902_write_reg(ndev, MAC1_REG, MAC1_SOFT_RESET);
+	ip3902_write_reg(ndev, POWERDOWN_REG, POWERDOWN_VALUE);
+#endif
+}
+
+#ifdef IP3902_POWERDOWN_PHY_ON_SUSPEND
+static void ip3902_phy_powerup(struct net_device *ndev)
+{
+	/* Poweron hardware */
+	ip3902_write_reg(ndev, POWERDOWN_REG, 0);
+
+	/* Move low level out of reset (also initialize the registers)*/
+	ip3902_write_reg(ndev, MAC1_REG, 0);
+	ip3902_write_reg(ndev, MAC2_REG, INITIAL_MAC2);
+
+	/* Set MII clock rate*/
+	ip3902_write_reg(ndev, MCFG_REG, 0x1c);
+
+	/* Write to reset bit in PHY control reg */
+	ip3902_mdio_write(ndev, ip3902_priv->mii.phy_id, 0x00, keep_phy_control);
+
+	/* Restart auto negotiation in PHY control reg */
+	ip3902_mdio_write(ndev, ip3902_priv->mii.phy_id, 0x00, (keep_phy_control | (0x1200)));
+}
+
+static void ip3902_phy_powerdown(struct net_device *ndev)
+{
+	/* Set MII clock rate*/
+	ip3902_write_reg(ndev, MCFG_REG, 0x1c);
+
+	/* Write to power down bit in PHY control reg */
+	keep_phy_control = ip3902_mdio_read(ndev, ip3902_priv->mii.phy_id, 0x00);
+	ip3902_mdio_write(ndev, ip3902_priv->mii.phy_id, 0x00, keep_phy_control | (1 << 11));
+
+	/* Put low-level hardware into reset, and high-level into poweroff */
+	ip3902_write_reg(ndev, MAC1_REG, MAC1_SOFT_RESET);
+	ip3902_write_reg(ndev, POWERDOWN_REG, POWERDOWN_VALUE);
+}
+#endif
+
+static int ip3902_hw_init(struct net_device *ndev, struct ip3902_private *ip3902_priv)
+{
+	int ret = 0;
+
+	/* Poweron hardware */
+	ip3902_write_reg(ndev, POWERDOWN_REG, 0);
+
+	/* Move low level out of reset (also initialize the registers)*/
+	ip3902_write_reg(ndev, MAC1_REG, 0);
+	ip3902_write_reg(ndev, MAC2_REG, INITIAL_MAC2);
+
+	ip3902_priv->mii.phy_id	= -EIO;
+	{
+		int addr;
+
+		for (addr = 1; addr < 32; addr++)
+		{
+			int stat;
+			stat = ip3902_mdio_read(ndev, addr, MII_BMSR);
+			if ((stat != 0) && (stat != 0xffff))
+			{
+				ip3902_priv->mii.phy_id	= addr;
+			}
+		}
+	}
+
+	if (ip3902_priv->mii.phy_id >= 0)
+	{
+		int addr;
+
+		ip3902_phy_reset(ndev, ip3902_priv);
+
+		for (addr = 1; addr < 32; addr++)
+		{
+			int stat;
+			stat = ip3902_mdio_read(ndev, addr, MII_BMSR);
+			if ((stat != 0) && (stat != 0xffff))
+			{
+				ip3902_priv->mii.phy_id	= addr;
+			}
+		}
+	}
+
+	if (ip3902_priv->mii.phy_id < 0)
+	{
+		ret = ip3902_priv->mii.phy_id;
+	}
+	else
+	{
+		ip3902_eth_update_mac_address(ndev);
+
+		/* "Initialize" command register (before resets - those routines
+		 * use read-modify-write operations on that register */
+		ip3902_write_reg(ndev, COMMAND_REG, COMMAND_ALLOW_SHORT);
+
+		/* Reset and configure Rx and Tx */
+		ip3902_reset_tx(ndev, ip3902_priv, 1);
+		ip3902_reset_rx(ndev, ip3902_priv, 1);
+
+		/* Initialize Rx filtering */
+		ip3902_do_set_rx_filter(ndev, ip3902_priv);
+
+		/* Clear all interrupts, and enable interesting interrupts */
+		ip3902_write_reg(ndev, INT_CLEAR_REG, 0xffffffff);
+		ip3902_write_reg(ndev, INT_CLEAR_REG, 0);
+		ip3902_priv->int_en_mask = (TX_UNDERRUN_INT | RX_OVERRUN_INT | IP3902_RX_DONE_INT);
+		ip3902_write_reg(ndev, INT_ENABLE_REG, ip3902_priv->int_en_mask);
+
+		/* Start Tx and Rx hardware */
+		ip3902_start_tx(ndev);
+		ip3902_start_rx(ndev);
+
+#ifdef CONFIG_IP3902_RX_TIMER
+		timer_setup(&ip3902_priv->rx_timer, ip3902_rx_timer, 0);
+		ip3902_priv->rx_timer.expires = jiffies + 1;
+		add_timer(&ip3902_priv->rx_timer);
+#endif
+	}
+	return 0;
+}
+
+static int ip3902_open(struct net_device *ndev)
+{
+	struct ip3902_private *ip3902_priv = netdev_priv(ndev);
+	int ret;
+
+	dev_dbg(&ip3902_priv->ndev->dev, "%s: open\n", ndev->name);
+
+	ret = request_irq(ndev->irq, ip3902_interrupt, 0, ndev->name, ndev);
+	if (ret)
+	{
+		return ret;
+	}
+
+	ret = ip3902_hw_init(ndev, ip3902_priv);
+
+	if (ret)
+	{
+		return ret;
+	}
+
+	mii_check_media(&ip3902_priv->mii, netif_msg_link(ip3902_priv), 1);
+	set_duplex_mode(ndev, ip3902_priv->mii.full_duplex);
+
+	netif_start_queue(ndev);
+#ifdef CONFIG_IP3902_RX_NAPI
+	napi_enable(&ip3902_priv->napi);
+#endif
+
+	timer_setup(&ip3902_priv->timer, ip3902_timer, 0);
+	ip3902_priv->timer.expires = jiffies + ((24 * HZ) / 10);
+	add_timer(&ip3902_priv->timer);
+
+	ip3902_priv->running = 1;
+
+	return 0;
+}
+
+static int ip3902_close(struct net_device *ndev)
+{
+	struct ip3902_private *ip3902_priv = netdev_priv(ndev);
+
+	dev_dbg(&ip3902_priv->ndev->dev, "%s: close\n", ndev->name);
+
+	ip3902_priv->running = 0;
+	del_timer(&ip3902_priv->timer);
+	wmb();
+#ifdef CONFIG_IP3902_RX_NAPI
+	napi_disable(&ip3902_priv->napi);
+#endif
+	ip3902_hw_deinit(ndev);
+	netif_stop_queue(ndev);
+
+	ip3902_eth_free_all_tx_descs(ndev, ip3902_priv);
+
+#ifdef IP3902_POWERDOWN_PHY_ON_SUSPEND
+        ip3902_phy_powerdown(ndev);
+#endif
+	free_irq(ndev->irq, ndev);
+	return 0;
+}
+
+static int parse_mac_address(struct net_device *ndev)
+{
+	int n = sscanf(mac_address, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+			&ndev->dev_addr[0], &ndev->dev_addr[1],
+			&ndev->dev_addr[2], &ndev->dev_addr[3],
+			&ndev->dev_addr[4], &ndev->dev_addr[5]);
+
+	if (n == 6)
+	{
+		return 0;
+	}
+
+	printk(KERN_WARNING DRVNAME": failed to parse mac address string \"%s\"\n", mac_address);
+	return -EINVAL;
+}
+
+static void ip3902_hw_shutdown(struct net_device *ndev, struct ip3902_private *ip3902_priv)
+{
+	dma_free_coherent(&ip3902_priv->pdev->dev, sizeof(*(ip3902_priv->ds)), ip3902_priv->ds, ip3902_priv->ds_dma);
+}
+
+static int ip3902_hw_startup(struct net_device *ndev, struct ip3902_private *ip3902_priv)
+{
+	ip3902_priv->ds = dma_alloc_coherent(&ip3902_priv->pdev->dev, sizeof(*(ip3902_priv->ds)), &ip3902_priv->ds_dma, GFP_KERNEL);
+	if (!ip3902_priv->ds)
+	{
+		printk(KERN_ERR DRVNAME ": can't allocate DMA structure\n");
+		return -ENOMEM;
+	}
+
+	/* Poweron hardware */
+	ip3902_write_reg(ndev, POWERDOWN_REG, 0);
+
+	/* set mii clock */
+	ip3902_write_reg(ndev, MCFG_REG, 0x1c);
+
+	/* Move low level out of reset (also initialize the registers) */
+	ip3902_write_reg(ndev, MAC1_REG, 0);
+	ip3902_write_reg(ndev, MAC2_REG, INITIAL_MAC2);
+
+	if (!mac_address || parse_mac_address(ndev) < 0)
+	{
+		unsigned long val;
+
+		val = ip3902_read_reg(ndev, SA0_REG);
+		ndev->dev_addr[5] = (val >> 8) & 255;
+		ndev->dev_addr[4] = val & 255;
+		val = ip3902_read_reg(ndev, SA1_REG);
+		ndev->dev_addr[3] = (val >> 8) & 255;
+		ndev->dev_addr[2] = val & 255;
+		val = ip3902_read_reg(ndev, SA2_REG);
+		ndev->dev_addr[1] = (val >> 8) & 255;
+		ndev->dev_addr[0] = val & 255;
+	}
+
+	/* Put low-level hardware into reset, and high-level into poweroff */
+	ip3902_write_reg(ndev, MAC1_REG, MAC1_SOFT_RESET);
+	ip3902_write_reg(ndev, POWERDOWN_REG, POWERDOWN_VALUE);
+
+	return 0;
+}
+
+static const struct net_device_ops ip3902_netdev_ops =
+{
+	.ndo_open						= ip3902_open,
+	.ndo_stop						= ip3902_close,
+	.ndo_start_xmit					= ip3902_start_xmit,
+	.ndo_set_rx_mode			= ip3902_set_rx_filter,
+	.ndo_set_mac_address			= ip3902_eth_set_mac_address,
+	.ndo_do_ioctl					= ip3902_ioctl,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller			= ip3902_net_poll,
+#endif
+};
+
+#ifdef CONFIG_IP3902_RX_NAPI
+static int napi_rx_handler(struct napi_struct *napi, int budget)
+{
+	struct ip3902_private *ip3902_priv = container_of(napi, struct ip3902_private, napi);
+	unsigned long flags;
+	int rx_done;
+
+#if defined (CONFIG_TIME_DOCTOR)
+	timeDoctor_Info(TDI_COMMAND(TDI_START, TDI_EVENT), CHAR_ARRAY_TO_U32("POLL"), CHAR_ARRAY_TO_U32("3902"));
+#endif
+
+	rx_done = ip3902_eth_receive_queue(ip3902_priv->ndev, ip3902_priv, RX_RING_SIZE);
+	if(rx_done < budget) {
+#if defined (CONFIG_TIME_DOCTOR)
+		timeDoctor_Info(TDI_COMMAND(TDI_START, TDI_EVENT), CHAR_ARRAY_TO_U32("CPLT"), CHAR_ARRAY_TO_U32("3902"));
+#endif
+		napi_complete_done(napi, rx_done);
+		spin_lock_irqsave(&ip3902_priv->int_lock, flags);
+		ip3902_priv->int_en_mask |= RX_DONE_INT;
+		ip3902_write_reg(ip3902_priv->ndev, INT_ENABLE_REG, ip3902_priv->int_en_mask);
+		spin_unlock_irqrestore(&ip3902_priv->int_lock, flags);
+#if defined (CONFIG_TIME_DOCTOR)
+		timeDoctor_Info(TDI_COMMAND(TDI_STOP, TDI_EVENT), CHAR_ARRAY_TO_U32("CPLT"), CHAR_ARRAY_TO_U32("3902"));
+#endif
+	}
+
+#if defined (CONFIG_TIME_DOCTOR)
+	timeDoctor_Info(TDI_COMMAND(TDI_STOP, TDI_EVENT), CHAR_ARRAY_TO_U32("POLL"), CHAR_ARRAY_TO_U32("3902"));
+#endif
+
+	return rx_done;
+}
+#endif
+
+static int ip3902_init_dev(struct net_device *ndev, struct ip3902_private *ip3902_priv)
+{
+	int ret;
+
+	ret = ip3902_hw_startup(ndev, ip3902_priv);
+
+	if (!ret)
+	{
+		ndev->netdev_ops         = &ip3902_netdev_ops;
+		ndev->ethtool_ops        = &ip3902_ethtool_ops;
+		ndev->features           = 0;
+
+		ip3902_priv->msg_enable		= NETIF_MSG_LINK;
+		ip3902_priv->mii.phy_id_mask	= 0x1f;
+		ip3902_priv->mii.reg_num_mask	= 0x1f;
+		ip3902_priv->mii.mdio_read	= ip3902_mdio_read;
+		ip3902_priv->mii.mdio_write	= ip3902_mdio_write;
+		ip3902_priv->mii.dev		= ndev;
+
+#ifdef CONFIG_IP3902_RX_NAPI
+		netif_napi_add(ndev, &ip3902_priv->napi, napi_rx_handler, RX_RING_SIZE);
+#endif
+		ret = register_netdev(ndev);
+		if (ret)
+		{
+			ip3902_hw_shutdown(ndev, ip3902_priv);
+		}
+	}
+
+	return ret;
+}
+
+static int ip3902_remove(struct platform_device *pdev)
+{
+	struct net_device     *ndev = platform_get_drvdata(pdev);
+	struct ip3902_private *ip3902_priv = netdev_priv(ndev);
+
+	platform_set_drvdata(pdev, NULL);
+
+	unregister_netdev(ndev);
+#ifdef CONFIG_IP3902_RX_NAPI
+	netif_napi_del(&ip3902_priv->napi);
+#endif
+	iounmap(ip3902_priv->mem);
+	release_resource(ip3902_priv->bus);
+	kfree(ip3902_priv->bus);
+
+	free_netdev(ndev);
+
+	return 0;
+}
+
+/* ip3902_probe
+ *
+ * This is the entry point when the platform device system uses to
+ * notify us of a new device to attach to. Allocate memory, find
+ * the resources and information passed, and map the necessary registers.
+*/
+
+static int ip3902_probe(struct platform_device *pdev)
+{
+	struct net_device     *ndev;
+	struct ip3902_private *ip3902_priv;
+	struct resource       *res;
+	size_t                 size;
+	int                    ret;
+
+	ndev = alloc_etherdev(sizeof(struct ip3902_private));
+
+	if (ndev == NULL)
+	{
+		return -ENOMEM;
+	}
+
+	ip3902_priv = netdev_priv(ndev);
+
+	memset(ip3902_priv, 0, sizeof(struct ip3902_private));
+
+	spin_lock_init(&ip3902_priv->mii_lock);
+	spin_lock_init(&ip3902_priv->int_lock);
+
+	ip3902_priv->ndev = ndev;
+	ip3902_priv->pdev = pdev;
+
+	platform_set_drvdata(pdev, ndev);
+
+	/* find the platform resources */
+	ndev->irq  = platform_get_irq(pdev, 0);
+	if (ndev->irq < 0)
+	{
+		dev_err(&pdev->dev, "no IRQ specified\n");
+		ret = -ENXIO;
+		goto exit_mem;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL)
+	{
+		dev_err(&pdev->dev, "no MEM specified\n");
+		ret = -ENXIO;
+		goto exit_mem;
+	}
+	size = (res->end - res->start) + 1;
+
+	ip3902_priv->bus = request_mem_region(res->start & 0x1fffffff, size, pdev->name);
+	if (ip3902_priv->bus == NULL)
+	{
+		dev_err(&pdev->dev, "cannot reserve registers\n");
+ 		ret = -ENXIO;
+		goto exit_mem;
+	}
+
+	ip3902_priv->mem = ioremap(res->start & 0x1fffffff, size);
+	ndev->base_addr = (unsigned long)ip3902_priv->mem;
+
+	if (ip3902_priv->mem == NULL)
+	{
+		dev_err(&pdev->dev, "Cannot ioremap area (%08llx,%08llx)\n",
+			(unsigned long long)res->start,
+			(unsigned long long)res->end);
+
+ 		ret = -ENXIO;
+		goto exit_req;
+	}
+
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+
+	/* got resources, now initialise and register device */
+	ret = ip3902_init_dev(ndev, ip3902_priv);
+	if (!ret)
+	{
+		printk("NXP ip3902 10/100 Ethernet platform driver irq %d base %08lx\n", ndev->irq, ndev->base_addr);
+		return 0;
+	}
+
+ exit_req:
+	release_resource(ip3902_priv->bus);
+	kfree(ip3902_priv->bus);
+
+ exit_mem:
+	free_netdev(ndev);
+
+	return ret;
+}
+
+/* suspend and resume */
+
+#ifdef CONFIG_PM
+static int ip3902_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct net_device     *ndev = platform_get_drvdata(pdev);
+	struct ip3902_private *ip3902_priv = netdev_priv(ndev);
+
+	ip3902_priv->resume_open = ip3902_priv->running;
+
+	netif_device_detach(ndev);
+	ip3902_close(ndev);
+	return 0;
+}
+
+static int ip3902_resume(struct platform_device *pdev)
+{
+	struct net_device     *ndev = platform_get_drvdata(pdev);
+	struct ip3902_private *ip3902_priv = netdev_priv(ndev);
+
+	netif_device_attach(ndev);
+
+	if (ip3902_priv->resume_open)
+	{
+#ifdef IP3902_POWERDOWN_PHY_ON_SUSPEND
+		ip3902_phy_powerup(ndev);
+#endif
+		ip3902_open(ndev);
+	}
+	return 0;
+}
+
+#else
+#define ip3902_suspend NULL
+#define ip3902_resume  NULL
+#endif
+
+static struct platform_driver ip3902drv = {
+	.driver	= {
+		.name		= "ip3902-eth",
+		.owner		= THIS_MODULE,
+	},
+	.probe		= ip3902_probe,
+	.remove		= ip3902_remove,
+	.suspend	= ip3902_suspend,
+	.resume		= ip3902_resume,
+};
+
+static int __init ip3902drv_init(void)
+{
+	return platform_driver_register(&ip3902drv);
+}
+
+static void __exit ip3902drv_exit(void)
+{
+	platform_driver_unregister(&ip3902drv);
+}
+
+module_init(ip3902drv_init);
+module_exit(ip3902drv_exit);
+
+MODULE_DESCRIPTION("NXP ip3902 10/100 Ethernet platform driver");
+MODULE_AUTHOR("Chris Steel, <chris.steel@nxp.com>");
+MODULE_LICENSE("GPL v2");
diff -Naur linux-5.4.28.orig/drivers/net/ethernet/Kconfig linux-5.4.28/drivers/net/ethernet/Kconfig
--- linux-5.4.28.orig/drivers/net/ethernet/Kconfig	2020-03-25 10:26:00.000000000 +0300
+++ linux-5.4.28/drivers/net/ethernet/Kconfig	2020-04-14 14:42:13.063970332 +0300
@@ -183,4 +183,39 @@
 source "drivers/net/ethernet/xilinx/Kconfig"
 source "drivers/net/ethernet/xircom/Kconfig"
 
+config IP3902
+	tristate "NXP IP3902 ethernet hardware support"
+	depends on SOC_PNX8335 && ETHERNET
+	select MII
+	select CRC32
+	---help---
+	 This is a driver for NXP IP3902 ethernet hardware found
+	 in PNX8335 and probably other SOCs.
+
+if IP3902
+
+choice
+	prompt "IP3902 RX Mode"
+	default IP3902_RX_IRQ
+
+config IP3902_RX_NAPI
+	bool "RX with NAPI"
+	---help---
+	With NAPI, the softirq poll input queue.
+
+config IP3902_RX_IRQ
+	bool "RX in IRQ"
+	---help---
+	In IRQ mode, the received packet is passed to the netif_rx function.
+
+config IP3902_RX_TIMER
+	bool "RX in Timer"
+	---help---
+	In Timer mode, a check is made for the presence of a packet, 
+	 and if it is, it is passed to the netif_rx function.
+
+endchoice
+
+endif # IP3902
+
 endif # ETHERNET
diff -Naur linux-5.4.28.orig/drivers/net/ethernet/Makefile linux-5.4.28/drivers/net/ethernet/Makefile
--- linux-5.4.28.orig/drivers/net/ethernet/Makefile	2020-03-25 10:26:00.000000000 +0300
+++ linux-5.4.28/drivers/net/ethernet/Makefile	2020-04-14 14:42:37.515720916 +0300
@@ -96,3 +96,4 @@
 obj-$(CONFIG_NET_VENDOR_XIRCOM) += xircom/
 obj-$(CONFIG_NET_VENDOR_SYNOPSYS) += synopsys/
 obj-$(CONFIG_NET_VENDOR_PENSANDO) += pensando/
+obj-$(CONFIG_IP3902) += ip3902.o
